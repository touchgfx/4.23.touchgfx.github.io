"use strict";(self.webpackChunktouchgfx_documentation=self.webpackChunktouchgfx_documentation||[]).push([[62818],{49613:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var r=n(59496);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(n),u=a,f=d["".concat(l,".").concat(u)]||d[u]||h[u]||o;return n?r.createElement(f,i(i({ref:t},c),{},{components:n})):r.createElement(f,i({ref:t},c))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:a,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},84596:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>c});n(59496);var r=n(49613);function a(){return a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},a.apply(this,arguments)}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}const i={id:"vector-fonts",title:"Vector Fonts"},s=void 0,l={unversionedId:"development/ui-development/touchgfx-engine-features/vector-fonts",id:"development/ui-development/touchgfx-engine-features/vector-fonts",title:"Vector Fonts",description:"TouchGFX supports using fonts in vector format starting from version 4.23. Fonts stored in vector format can potentially reduce the size of the font data as the font data is shared between all sizes of a font. This is in contrast to bitmap fonts where every size of a font contains dedicated bitmaps of the glyphs in that size.",source:"@site/i18n/zh-TW/docusaurus-plugin-content-docs/current/development/ui-development/touchgfx-engine-features/vector-fonts.mdx",sourceDirName:"development/ui-development/touchgfx-engine-features",slug:"/development/ui-development/touchgfx-engine-features/vector-fonts",permalink:"/4.23/zh-TW/docs/development/ui-development/touchgfx-engine-features/vector-fonts",draft:!1,tags:[],version:"current",frontMatter:{id:"vector-fonts",title:"Vector Fonts"},sidebar:"docs",previous:{title:"SVG",permalink:"/4.23/zh-TW/docs/development/ui-development/touchgfx-engine-features/svg"},next:{title:"\u5716\u50cf\u58d3\u7e2e",permalink:"/4.23/zh-TW/docs/development/ui-development/touchgfx-engine-features/image-compression"}},p={},c=[{value:"What are vector fonts",id:"what-are-vector-fonts",level:2},{value:"Example",id:"example",level:3},{value:"Configuration",id:"vector-configuration",level:2},{value:"Using vector fonts",id:"vector-using",level:2},{value:"Typographies",id:"vector-typographies",level:2},{value:"Architecture",id:"vector-architecture",level:2},{value:"Limitations",id:"vector-limitations",level:2},{value:"Storage",id:"vector-storage",level:3},{value:"Thai",id:"thai",level:3}],d={toc:c},h="wrapper";function u(e){var{components:t}=e,n=o(e,["components"]);return(0,r.kt)(h,a({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"TouchGFX supports using fonts in vector format starting from version 4.23. Fonts stored in vector format can potentially reduce the size of the font data as the font data is shared between all sizes of a font. This is in contrast to bitmap fonts where every size of a font contains dedicated bitmaps of the glyphs in that size."),(0,r.kt)("p",null,"Vector fonts are used on the user interface just like the normal bitmap fonts using widgets like TextArea or ButtonWithLabel."),(0,r.kt)("p",null,"To use the vector font format, the vector font functionality must be enabled for the platform in STM32CubeMX."),(0,r.kt)("p",null,"Vector fonts are only supported on 16bpp, 24bpp, or 32bpp frame buffers."),(0,r.kt)("h2",a({},{id:"what-are-vector-fonts"}),"What are vector fonts"),(0,r.kt)("p",null,"Vector fonts are fonts where the individual letters are described by curves and lines. These curves and lines can be scaled up and down to produce glyphs in different sizes. All the fonts we normally use in TouchGFX are vector fonts (for example TrueType or OpenType fonts). The curves and lines in the font description are converted to many small bitmaps by the TouchGFX Font Converter when TouchGFX Designer generates assets."),(0,r.kt)("p",null,"The conversion of vector fonts to bitmaps is based on the typographies defined in TouchGFX Designer. For example, an application may use two typographies, Large and Small. Large could be based on Verdana in size 30 and Small could be based on Verdana in size 20. If we assume that the application is using the glyphs A-Z and a-z in these typographies we get 52 glyphs for each typography, but the appplication will contain 104 bitmaps, as we get two bitmaps for each letter. One bitmap for size 30 and one for size 20."),(0,r.kt)("p",null,"Vector fonts are different because we keep the vector definition for a glyph and do not create a bitmap of the glyph. This vector definition is instead included in the target application one time only. The only extra data that is needed to produce the two required typographies is two different scaling factors. One to scale the vector definitions to size 30 and one to scale to size 20."),(0,r.kt)("p",null,"As a result, if we add another typography size to the example application - for example Verdana in size 40 - the flash requirement will only increase marginally."),(0,r.kt)("h3",a({},{id:"example"}),"Example"),(0,r.kt)("p",null,'To give an example, the vector definition for "G" in the Truetype font Verdana is 170 bytes.'),(0,r.kt)("p",null,'The size of the bitmap representing the glyph depends on the bpp used and the size of the glyph. The table below shows the bitmap size for "G" in various glyph sizes in 4bpp:'),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",a({parentName:"tr"},{align:null}),"Font size"),(0,r.kt)("th",a({parentName:"tr"},{align:null}),"G glyph dimension / pixels"),(0,r.kt)("th",a({parentName:"tr"},{align:null}),"Bitmap size / bytes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",a({parentName:"tr"},{align:null}),"20"),(0,r.kt)("td",a({parentName:"tr"},{align:null}),"14 x 14"),(0,r.kt)("td",a({parentName:"tr"},{align:null}),"98")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",a({parentName:"tr"},{align:null}),"30"),(0,r.kt)("td",a({parentName:"tr"},{align:null}),"21 x 22"),(0,r.kt)("td",a({parentName:"tr"},{align:null}),"242")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",a({parentName:"tr"},{align:null}),"40"),(0,r.kt)("td",a({parentName:"tr"},{align:null}),"27 x 32"),(0,r.kt)("td",a({parentName:"tr"},{align:null}),"448")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",a({parentName:"tr"},{align:null}),"Total"),(0,r.kt)("td",a({parentName:"tr"},{align:null})),(0,r.kt)("td",a({parentName:"tr"},{align:null}),"788")))),(0,r.kt)("p",null,'We see that the bitmap size for font size 20 is smaller than the vector definition of "G", but already at size 30 the vector definition is smaller than the bitmap size. And if we use three different sizes of Verdana, we use 788 bytes for the bitmaps while the vector definition still only uses 170 bytes. We therefore save 78% of the flash usage.'),(0,r.kt)("p",null,"This storage saving comes with a disadvantage - performance. When we need to draw a glyph, we have to convert the vector definition to pixels. This is done by scaling and translating the vector definition of a glyph and then render it to the framebuffer."),(0,r.kt)("p",null,'A single "G" in Verdana consists of 20 Bezier curves and 6 straight line-pieces. These are all converted into an outline, which is finally colored using the selected text color. This process is repeated for all the letters in the text and repeated whenever the text is redrawn.'),(0,r.kt)("p",null,"The above process is hardware accelerated on microcontrollers with GPU2D (for example STM32U5G9) where it works well. On slow microcontrollers like STM32G0, without floating point hardware, it would be very demanding for the hardware to perform these operations."),(0,r.kt)("p",null,"In such cases, the rendering time would be better if bitmap fonts are used. It is therefore recommended to use vector fonts where the flash-savings are necessary and otherwise use bitmap fonts.",(0,r.kt)("br",{parentName:"p"}),"\n","If a text is animated (scrolled, moved or faded) it is recommended to use bitmap fonts."),(0,r.kt)("h2",a({},{id:"vector-configuration"}),"Configuration"),(0,r.kt)("p",null,"The use of vector fonts requires the additional framework features ",(0,r.kt)("inlineCode",{parentName:"p"},"Vector Rendering")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Vector Fonts"),". These are enabled in STM32CubeMX. See the ",(0,r.kt)("a",a({parentName:"p"},{href:"../../touchgfx-hal-development/generator-how-to/touchgfx-al-configuration/additional-features#vector-rendering"}),"Generator User Guide")," for more information."),(0,r.kt)("p",null,"Typographies are configured in TouchGFX Designer. Here you can select if a typography should use bitmap font format or a vector font format in for the project. The default is bitmap font format."),(0,r.kt)("h2",a({},{id:"vector-using"}),"Using vector fonts"),(0,r.kt)("p",null,"Vector fonts are used exactly as bitmap fonts in TouchGFX. You create texts either as named resources or single use texts. You show the text in one of the widgets, for example a TextArea. The differences between vector fonts and bitmap fonts are hidden in the rendering code."),(0,r.kt)("h2",a({},{id:"vector-typographies"}),"Typographies"),(0,r.kt)("p",null,"Vector fonts are generated when a typography in is configured to be vector based in TouchGFX Designer. See the ",(0,r.kt)("a",a({parentName:"p"},{href:"../designer-user-guide/texts-view#typographies"}),"Designer User Guide"),"."),(0,r.kt)("p",null,"If multiple typographies uses the same font (e.g. Verdana), the typographies will share the vector definitions in the project, but use them with a different scale factor to produce glyphs of different sizes."),(0,r.kt)("p",null,"This also means that the typography attributes ",(0,r.kt)("inlineCode",{parentName:"p"},"Fallback Character")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Ellipsis Character")," must be the same for the typographies."),(0,r.kt)("p",null,"The characters used in the typographies (including wildcard characters) are combined and made available for all the typographies in the project using the same font."),(0,r.kt)("h2",a({},{id:"vector-architecture"}),"Architecture"),(0,r.kt)("p",null,"Rendering of vector fonts is based on a new component ",(0,r.kt)("inlineCode",{parentName:"p"},"VectorFontRenderer"),". This component uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"VectorRenderer")," component to draw the glyphs."),(0,r.kt)("p",null,"In a project that uses vector fonts, these two components must be made available. This is done by STM32CubeMX automatically if these are enabled. It must be done manually if you are not using STM32CubeMX."),(0,r.kt)("p",null,"Here is the code generated by STM32CubeMX with the relevant lines highlighted:"),(0,r.kt)("pre",null,(0,r.kt)("code",a({parentName:"pre"},{className:"language-cpp",metastring:"{5-5,19-19}","{5-5,19-19}":!0}),"static STM32TouchController tc;\nstatic STM32DMA dma;\nstatic TouchGFXDataReader dataReader;\nstatic LCD16bppSerialFlash display(dataReader);\nstatic VectorFontRendererImpl vectorFontRenderer;\nstatic ApplicationFontProvider fontProvider;\nstatic Texts texts;\nstatic TouchGFXHAL hal(dma, display, tc, 240, 320);\n\nvoid touchgfx_init()\n{\n    Bitmap::registerBitmapDatabase(BitmapDatabase::getInstance(), BitmapDatabase::getInstanceSize());\n    TypedText::registerTexts(&texts);\n    Texts::setLanguage(0);\n\n    hal.setDataReader(&dataReader);\n    fontProvider.setFlashReader(&dataReader);\n\n    display.setVectorFontRenderer(&vectorFontRenderer);\n    ...\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"VectorRenderer")," component must also be provided (from ",(0,r.kt)("inlineCode",{parentName:"p"},"TouchGFXGeneratedHAL.cpp"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",a({parentName:"pre"},{className:"language-cpp"}),"namespace touchgfx\n{\nVectorRenderer* VectorRenderer::getInstance()\n{\n    static CWRVectorRendererRGB565 renderer;\n\n    return &renderer;\n}\n} // namespace touchgfx\n")),(0,r.kt)("p",null,"If you are on a platform with the GPU2D accelerator, you should use ",(0,r.kt)("inlineCode",{parentName:"p"},"CPU2DVectorRenderer")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"CWRVectorRendererRGB565"),". This will enable hardware acceleration."),(0,r.kt)("h2",a({},{id:"vector-limitations"}),"Limitations"),(0,r.kt)("h3",a({},{id:"vector-storage"}),"Storage"),(0,r.kt)("p",null,"Vector font data must be stored in a memory mapped area. This can be internal flash, external QSPI/OSPI flash in memory-mapped mode, RAM, or other similar memories."),(0,r.kt)("p",null,"If your platform stores other font data in non-memory-mapped data you must change the linker script to move all vector font data to e.g. internal flash. Here is how to do this with ARM gcc:"),(0,r.kt)("pre",null,(0,r.kt)("code",a({parentName:"pre"},{}),'  /* Constant data into "FLASH" Rom type memory */\n  .FontFlashSection :\n  {\n    . = ALIGN(4);\n    */Vector_*.o(FontFlashSection)         /* Vector font data  */\n    . = ALIGN(4);\n  } >FLASH\n\n  FontFlashSection :\n  {\n    *(FontFlashSection FontFlashSection.*)\n    *(.gnu.linkonce.r.*)\n    . = ALIGN(0x4);\n  } >SPI_FLASH\n')),(0,r.kt)("p",null,"This puts font data from files matching ",(0,r.kt)("inlineCode",{parentName:"p"},"*/Vector_*.o/")," into the ",(0,r.kt)("inlineCode",{parentName:"p"},"FLASH")," region and other font data into the ",(0,r.kt)("inlineCode",{parentName:"p"},"SPI_FLASH")," region."),(0,r.kt)("p",null,"Vector font data is generated into files like ",(0,r.kt)("inlineCode",{parentName:"p"},"generated/fonts/src/Vector_Font_Verdana.cpp")," and similar."),(0,r.kt)("h3",a({},{id:"thai"}),"Thai"),(0,r.kt)("p",null,"It is a known issue that Thai does not render correctly with vector fonts. The work around is to use a bitmap font for Thai."))}u.isMDXComponent=!0}}]);