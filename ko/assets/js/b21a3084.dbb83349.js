"use strict";(self.webpackChunktouchgfx_documentation=self.webpackChunktouchgfx_documentation||[]).push([[42298],{49613:(e,t,a)=>{a.d(t,{Zo:()=>h,kt:()=>u});var n=a(59496);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),m=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},h=function(e){var t=m(e.components);return n.createElement(l.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,h=i(e,["components","mdxType","originalType","parentName"]),p=m(a),d=r,u=p["".concat(l,".").concat(d)]||p[d]||c[d]||o;return a?n.createElement(u,s(s({ref:t},h),{},{components:a})):n.createElement(u,s({ref:t},h))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,s=new Array(o);s[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[p]="string"==typeof e?e:r,s[1]=i;for(var m=2;m<o;m++)s[m]=a[m];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},61235:(e,t,a)=>{a.d(t,{Z:()=>o});var n=a(59496);class r extends n.Component{render(){return n.createElement("div",{className:"code-header"},n.createElement("div",null,n.createElement("h5",null,this.props.children)))}}const o=r},12822:(e,t,a)=>{a.d(t,{Z:()=>o});var n=a(59496),r=a(32118);const o=function(e){const t=e.noShadow||!1,a=e.width,o=e.height,s=(0,r.Z)(e.imageSource);return t?n.createElement("div",{className:"figure noshadow"},n.createElement("a",{href:s,target:"_blank"},n.createElement("img",{width:a,height:o,src:s})),n.createElement("p",null,e.children)):n.createElement("div",{className:"figure"},n.createElement("a",{href:s,target:"_blank"},n.createElement("img",{width:a,height:o,src:s})),n.createElement("p",null,e.children))}},86222:(e,t,a)=>{a.d(t,{Z:()=>i});var n=a(59496),r=a(89588);const o=n.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},n.createElement("path",{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}));class s extends n.Component{render(){return n.createElement(r.Z,{color:"var(--highlight-color-further-reading)",header:"Further reading",type:"further-reading",icon:o},this.props.children)}}const i=s},89588:(e,t,a)=>{a.d(t,{Z:()=>o});var n=a(59496);class r extends n.Component{render(){const e=`highlight highlight-${this.props.type}`;return n.createElement("div",{className:e},n.createElement("div",{className:"highlight-heading"},n.createElement("h5",null,n.createElement("div",{className:"highlight-icon"},this.props.icon),this.props.header)),n.createElement("div",{className:"highlight-content"},this.props.children))}}const o=r},16219:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>p,default:()=>b,frontMatter:()=>h,metadata:()=>c,toc:()=>u});a(59496);var n=a(49613),r=a(12822),o=a(86222),s=a(51721),i=a(61235);function l(){return l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e},l.apply(this,arguments)}function m(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}const h={id:"flash-limited-gui-development",title:"Flash-limited GUI development",slug:"/flash-limited"},p=void 0,c={unversionedId:"development/scenarios/flash-limited-gui-development",id:"development/scenarios/flash-limited-gui-development",title:"Flash-limited GUI development",description:"This article explains how to use TouchGFX to develop graphical user interfaces with low flash memory usage.",source:"@site/i18n/ko/docusaurus-plugin-content-docs/current/development/scenarios/flash-limited-gui-development.mdx",sourceDirName:"development/scenarios",slug:"/flash-limited",permalink:"/4.23/ko/docs/flash-limited",draft:!1,tags:[],version:"current",frontMatter:{id:"flash-limited-gui-development",title:"Flash-limited GUI development",slug:"/flash-limited"},sidebar:"docs",previous:{title:"\ubd80\ubd84 \ud504\ub808\uc784 \ubc84\ud37c\ub97c \ud1b5\ud55c \uba54\ubaa8\ub9ac \uc0ac\uc6a9 \uc808\uac10",permalink:"/4.23/ko/docs/development/scenarios/lowering-memory-usage-with-partial-framebuffer"},next:{title:"\uba54\ubaa8\ub9ac \ub9e4\ud551 \ubaa8\ub4dc\uac00 \uc544\ub2cc \ud50c\ub798\uc2dc\ub97c \uc0ac\uc6a9\ud558\uc5ec \uc774\ubbf8\uc9c0 \uc800\uc7a5",permalink:"/4.23/ko/docs/development/scenarios/using-non-memory-mapped-flash"}},d={},u=[{value:"Flash-limited E-bike demo",id:"flash-limited-e-bike-demo",level:2},{value:"When to use which concept",id:"when-to-use-which-concept",level:2},{value:"L8 and compression",id:"L8-and-compression",level:3},{value:"SVG",id:"SVG",level:3},{value:"Vector Fonts",id:"vector-fonts",level:3},{value:"Examples",id:"examples",level:3},{value:"Conclusion",id:"concept-conclusion",level:3},{value:"Using &#39;&#39;smart&#39;&#39; assets",id:"smart-assets",level:2},{value:"Simple assets",id:"simple-assets",level:3},{value:"Using boxes",id:"using-boxes",level:3},{value:"Reusable assets",id:"reusable-assets",level:3},{value:"Improving performance",id:"performance",level:2},{value:"Conclusion",id:"conclusion",level:2}],f={toc:u},g="wrapper";function b(e){var{components:t}=e,a=m(e,["components"]);return(0,n.kt)(g,l({},f,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"This article explains how to use TouchGFX to develop graphical user interfaces with low flash memory usage."),(0,n.kt)("p",null,"When generating code with TouchGFX, assets like images, texts and fonts are converted to C++ files, which are then stored in flash memory during programming along with TouchGFX application code, user code and TouchGFX libraries. This means that large or complex projects with many assets will result in high flash usage."),(0,n.kt)("p",null,"Since memory resources are limited in most applications, there are ways to decrease the amount of flash memory needed. TouchGFX has four built-in features, which can help you decrease the flash memory needed for your application significantly. The four concepts are L8 image format, image compression, scalable vector graphics (SVG) and vector fonts."),(0,n.kt)("p",null,"In this article we will now see how to utilize the four concepts to limit the flash memory footprint of an application. The measurements were performed using an STM32U5G9J-DK2, but the concepts to save flash can be applied to other hardware platforms as well."),(0,n.kt)(o.Z,{mdxType:"FurtherReading"},"Read also about ",(0,n.kt)(s.Z,{to:"../../basic-concepts/memory-usage",mdxType:"Link"},"Memory Usage"),"."),(0,n.kt)("h2",l({},{id:"flash-limited-e-bike-demo"}),"Flash-limited E-bike demo"),(0,n.kt)("p",null,"A flash-limited E-bike demo, which demonstrates how to use the four features to save flash with TouchGFX can be found in TouchGFX Designer. The demo is a board specific demo for STM32U5G9J-DK2. A benefit from using the STM32U5G9J-DK2 is that it has NeoChromVG GPU, which hardware accelerates vector rendering. However, especially L8 image format and image compression can be used across all STM32 MCUs."),(0,n.kt)("p",null,"If the demo was implemented with only uncompressed bitmaps (without L8, compression, SVG and vector fonts), it would take up approximately 10.5 MB of flash memory. In the implementation, where the four concepts to save flash are used, the demo only takes up approximately 800 KB of flash memory. As seen from this, it is possible to save a substantial amount of flash. In the demo, the four concepts combined gives a flash saving of 92%."),(0,n.kt)("h2",l({},{id:"when-to-use-which-concept"}),"When to use which concept"),(0,n.kt)("p",null,"Technical information and guides on how to use the four flash saving concepts with TouchGFX can be found here:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",l({parentName:"li"},{href:"../ui-development/scenarios/using-the-l8-image-format-to-reduce-memory-consumption"}),"L8 Image Format")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",l({parentName:"li"},{href:"../ui-development/touchgfx-engine-features/image-compression"}),"Image Compression")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",l({parentName:"li"},{href:"../ui-development/touchgfx-engine-features/svg"}),"SVG")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",l({parentName:"li"},{href:"../ui-development/touchgfx-engine-features/vector-fonts"}),"Vector Fonts"))),(0,n.kt)("p",null,"The four concepts can all help to decrease the amount of flash memory needed for an application. When to use which concept depends on the scenario, but some general rules can be applied. We will now go through these."),(0,n.kt)("h3",l({},{id:"L8-and-compression"}),"L8 and compression"),(0,n.kt)("p",null,"When using L8 image format on a bitmap, the bitmap can have a maximum of 256 colors. The rendering of assets in L8 format is hardware accelerated with ",(0,n.kt)("a",l({parentName:"p"},{href:"../hardware-selection/hardware-components/hardware-selection-mcu#chrom-art"}),"Chrom-ART"),", meaning that the render time for L8 bitmaps are almost the same as for regular bitmaps. Sometimes it is even faster to render a bitmap in L8 format compared to a regular bitmap, since less data is read from the flash memory. L8 can save you more than 70% of flash compared to a regular bitmap with a color depth of 32-bits."),(0,n.kt)("p",null,"Image compression can help you to save even more flash compared to L8. To use image compression on a bitmap, the bitmap needs to be in L8 format first, since the compression algorithms use the color look-up table. As a result of this, compressed bitmaps are still limited to a maximum of 256 colors. Some of the compression algorithms have further limitations on the maximum number of colors. L4 is limited to a maximum of 16 colors and RLE is limited to a maximum of 64 colors. Opposed to rendering of L8 bitmaps, which are hardware accelerated with Chrom-ART, compressed bitmaps are software rendered and are hence more expensive to render. One further limitation of compressed bitmaps is that they can't be used in scalable or rotatable widgets."),(0,n.kt)("p",null,"Both L8 image format and image compression are easy to use, if you already have your assets in PNG-format. In general you could always use L8 image format on bitmaps with maximum 256 colors without any significant performance penalty. If you need to save even more flash and have available render time to achieve the required performance, you could use image compression as well. However, if you need to use your bitmap in scalable or rotatable widgets, you can't use compressed bitmaps natively. There are of course ways around this, which we will briefly cover later."),(0,n.kt)("h3",l({},{id:"SVG"}),"SVG"),(0,n.kt)("p",null,"Another option to save flash on assets is to have them in SVG-format instead of PNG-format. SVGs has no limitation on the number of colors. However, SVGs are usually more costly to render compared to L8 and compression. Therefore, it is recommended to limit the number of concurrent SVGs and to keep animations with SVGs to a minimum. The simpler your SVG assets are, the smaller the resulting flash footprint will be and the better performance can be achieved. In line with this, it is recommended to only use one-layer SVGs."),(0,n.kt)("p",null,"To use an asset in an SVG widget, you need to import the asset in SVG-format. The assets can't be converted by TouchGFX."),(0,n.kt)("h3",l({},{id:"vector-fonts"}),"Vector Fonts"),(0,n.kt)("p",null,"As for non-font assets in SVG-format, Vector Fonts are also expensive to render, since it is rendered in the same way as SVGs. Vector Fonts are generally beneficial to use for large font sizes or if the same font is used in several different sizes. If you have the same font in different sizes and vector representation, it is only needed to store the font once. Then, only a scaling factor is needed to represent it in different sizes. For bitmap fonts each of the font sizes needs to be stored separately. Vector Fonts will often not yield as big a flash saving as image compression and SVG. Therefore, it should mainly be used, if it is necessary to limit the flash memory footprint to the absolute minimum."),(0,n.kt)("h3",l({},{id:"examples"}),"Examples"),(0,n.kt)("p",null,"To provide specific examples of the characteristics of the different concepts, measurements are performed on two assets from the E-bike demo in regular bitmap, L8, RLE compressed and SVG-format. The measurements are performed on the STM32U5G9J-DK2 with assets in internal flash. The render time of SVG will be longer for MCUs not having NeoChrom GPU. However, a faster CPU could also compensate for this."),(0,n.kt)("p",null,"The asset below has a color depth of 32-bits and is a button with an icon on top. The button is 122 x 112 px and the icon is 72 x 72 px."),(0,n.kt)(r.Z,{imageSource:"/img/development/scenarios/flash-limited-gui-development/button-with-icon.webp",mdxType:"Figure"},"Button with icon from E-bike demo"),(0,n.kt)("p",null,"The following measurements are performed on the asset:"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",l({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Format")),(0,n.kt)("th",l({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Size")),(0,n.kt)("th",l({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Pct.")),(0,n.kt)("th",l({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Render time")),(0,n.kt)("th",l({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"CPU load")))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",l({parentName:"tr"},{align:null}),"Bitmap:"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"75.4 KB"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"100%"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"0.414 ms"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"2.4%")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",l({parentName:"tr"},{align:null}),"L8:"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"19.3 KB"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"25.6%"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"0.448 ms"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"2.3%")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",l({parentName:"tr"},{align:null}),"L8 RLE:"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"2.55 KB"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"3.4%"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"1.51 ms"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"9.6%")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",l({parentName:"tr"},{align:null}),"SVG:"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"3.01 KB"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"4.0%"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"1.43 ms"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"4.1%")))),(0,n.kt)("p",null,"As seen from this, RLE has the lowest flash footprint, but takes approximately 1 ms longer to render compared to regular bitmap format."),(0,n.kt)("p",null,"The asset below has a color depth of 32-bits and is a part of the gauge in the dashboard screen in the demo. It is 150 x 436 px."),(0,n.kt)(r.Z,{imageSource:"/img/development/scenarios/flash-limited-gui-development/gauge-part.webp",mdxType:"Figure"},"Part of gauge from E-bike demo"),(0,n.kt)("p",null,"The following measurements are performed on the asset:"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",l({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Format")),(0,n.kt)("th",l({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Size")),(0,n.kt)("th",l({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Pct.")),(0,n.kt)("th",l({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Render time")),(0,n.kt)("th",l({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"CPU load")))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",l({parentName:"tr"},{align:null}),"Bitmap:"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"261.6 KB"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"100%"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"1.15 ms"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"1.5%")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",l({parentName:"tr"},{align:null}),"L8:"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"65.6 KB"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"25.1%"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"1.24 ms"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"1.4%")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",l({parentName:"tr"},{align:null}),"L8 RLE:"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"4.66 KB"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"1.78%"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"2.75 ms"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"15.0%")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",l({parentName:"tr"},{align:null}),"SVG:"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"0.686 KB"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"0.27%"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"3.40 ms"),(0,n.kt)("td",l({parentName:"tr"},{align:null}),"2.0%")))),(0,n.kt)("p",null,"The asset in SVG-format has the by far lowest flash footprint, but is also the most expensive to render."),(0,n.kt)("h3",l({},{id:"concept-conclusion"}),"Conclusion"),(0,n.kt)("p",null,"As seen above, none of the formats are best for all assets. However, for flash saving alone, image compression generally has the smallest flash footprint when the asset is relatively small, and SVG has the smallest flash footprint when the asset is larger. Even though SVG assets can have more than 256 colors, it is still recommended to keep SVG assets relatively simple for both flash memory usage and performance considerations. L8 image format has the highest flash footprint among L8, image compression and SVG, but L8 has the lowest render time."),(0,n.kt)("p",null,"Therefore, when developing a flash-limited application, you need to identify the bottleneck and determine what matters most for you application. Is it performance or flash memory savings? If it is performance, L8 will be the most efficient approach. It could even be combined with compression for some assets if performance allows it. If it is most important to have the smallest possible flash footprint, image compression and SVG will be the best approach."),(0,n.kt)("h2",l({},{id:"smart-assets"}),"Using ''smart'' assets"),(0,n.kt)("p",null,"Both flash savings and performance can be improved by using ''smart'' assets. Here, smart assets both refer to the assets themselves and their usage."),(0,n.kt)("h3",l({},{id:"simple-assets"}),"Simple assets"),(0,n.kt)("p",null,"First of all, the simpler the assets are, the more they can be compressed and the simpler the SVG definitions will be as well. This will in the end result in a smaller flash footprint."),(0,n.kt)("p",null,"As a reference, in the E-bike demo all bitmap assets have a maximum of 64 colors and since the assets are also well-suited for RLE, all the bitmap assets are RLE compressed. Since RLE is faster to render compared to LZW9, this also gives the best performance."),(0,n.kt)("p",null,"Additionally, if the design is also simple, you can in some cases use a ",(0,n.kt)("a",l({parentName:"p"},{href:"../ui-development/ui-components/images/tiled-image"}),"Tiled Image")," as well. Then you only need to store a part of the image, which can then be repeated."),(0,n.kt)("h3",l({},{id:"using-boxes"}),"Using boxes"),(0,n.kt)("p",null,"Another way of saving flash memory in a smart way is to use the ",(0,n.kt)("a",l({parentName:"p"},{href:"../ui-development/ui-components/shapes/box"}),"Box widget"),". Using boxes has two main benefits:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Firstly, the box will be drawn directly in the framebuffer. As a result of this, no flash memory is needed to store the box. The only flash impact will be from the small amount of code needed to define the box."),(0,n.kt)("li",{parentName:"ol"},"Secondly, boxes are adaptable and it is possible to change both color and size at runtime. In the flash-limited E-bike demo, boxes have been used for e.g. solid background colors to support both light- and dark mode by changing the color of the box.")),(0,n.kt)("h3",l({},{id:"reusable-assets"}),"Reusable assets"),(0,n.kt)("p",null,"Another way to save flash memory is to limit the total number of assets. This can of course be achieved by having a very simple design, but it is sometimes also possible to limit the existing number of assets by reusing the same asset multiple times."),(0,n.kt)("p",null,"In the flash-limited E-bike demo, this approach is, for example, used in the weather screens. The weather icons are the same asset that is scaled to fit all 3 sizes. Since it is a scaled asset, SVG format is preferred over compression even though the flash footprint is smaller with RLE. However, the total flash footprint would be bigger if the asset was stored in RLE format in all 3 sizes."),(0,n.kt)("p",null,"Additionally, the buttons are also implemented as a reusable asset. For example, the buttons are separated from their icons to allow it to be reused."),(0,n.kt)("p",null,"Another case where reusability is used in the demo is with the background. There are a total of 5 different background designs in the demo, but by using adaptable assets (boxes and reuseable assets), all the backgrounds are created with just one asset and a box."),(0,n.kt)("h2",l({},{id:"performance"}),"Improving performance"),(0,n.kt)("p",null,"When developing a flash-limited application there is a risk of hurting performance. However, if spare RAM is available, there are ways to improve the performance of the application. By using ",(0,n.kt)("a",l({parentName:"p"},{href:"../ui-development/touchgfx-engine-features/dynamic-bitmaps"}),"Dynamic Bitmaps")," and ",(0,n.kt)("a",l({parentName:"p"},{href:"../ui-development/scenarios/achieving-better-performance-with-cacheable-container"}),"Cacheable Containers"),", it is possible to draw static snapshots of assets or containers to RAM. Then, whenever using the asset or container, the cached version can be used instead. The cached version is just a bitmap in RAM, which means that the render time is identical to rendering regular bitmaps."),(0,n.kt)("p",null,"In the flash-limited E-bike demo, cachable containers are used to allow scrolling of SVG assets and vector fonts, while keeping a good performance."),(0,n.kt)(r.Z,{imageSource:"/img/development/scenarios/flash-limited-gui-development/cacheable-container.webp",width:"500",mdxType:"Figure"},"Weather element as cacheable container"),(0,n.kt)("p",null,"In general vector fonts are cached whenever they are moved or movable on runtime. This ensures a minimum of 30 FPS despite scrolling vector fonts."),(0,n.kt)("p",null,"Another trick used in the demo is decompression of compressed bitmaps to the bitmap cache. By decompressing the bitmaps to RAM, it is possible to use them in scalable and rotatable widgets. When a bitmap is decompressed, TouchGFX will always use the decompressed cached version when referring to the bitmap ID. An example from the E-bike demo is seen below. The compressed bitmaps are simply decompressed and after this the bitmaps can be used just as regular bitmaps."),(0,n.kt)(i.Z,{mdxType:"CodeHeader"},"StartView.cpp"),(0,n.kt)("pre",null,(0,n.kt)("code",l({parentName:"pre"},{className:"language-cpp",metastring:"{21-25}","{21-25}":!0}),"StartView::StartView()\n{\n    Bitmap::decompress(BITMAP_MAIN_RIPPLE_LEFT_ID);     // Decompress compressed image to bitmap cache\n    Bitmap::decompress(BITMAP_MAIN_RIPPLE_RIGHT_ID);    // Decompress compressed image to bitmap cache\n}\n\nvoid StartView::setupScreen()\n{\n    leftMainRippleScale.setBitmap(BITMAP_MAIN_RIPPLE_LEFT_ID);      // Set bitmap for Scalable Image\n    rightMainRippleScale.setBitmap(BITMAP_MAIN_RIPPLE_RIGHT_ID);    // Set bitmap for Scalable Image\n    leftMainRippleScale.setWidthHeight(0, 0);       // Set scale of image\n    rightMainRippleScale.setWidthHeight(0, 0);      // Set scale of image\n}\n")),(0,n.kt)("p",null,"As a result of extensive use of dynamic bitmaps, the flash-limited E-bike demo requires a bitmap cache of 922 KB. This means that a lot of spare RAM is required. However, the demo also takes the flash saving to a quite extreme extent. In a more simple application or an application where performance requirements isn't that important, it would be possible to get away with a much smaller bitmap cache."),(0,n.kt)(o.Z,{mdxType:"FurtherReading"},(0,n.kt)("li",null,(0,n.kt)(s.Z,{to:"../ui-development/touchgfx-engine-features/dynamic-bitmaps",mdxType:"Link"},"Dynamic Bitmaps")),(0,n.kt)("li",null,(0,n.kt)(s.Z,{to:"../ui-development/scenarios/achieving-better-performance-with-cacheable-container",mdxType:"Link"},"Achieving Better Performance with Cacheable Container")),(0,n.kt)("li",null,(0,n.kt)(s.Z,{to:"../ui-development/touchgfx-engine-features/image-compression",mdxType:"Link"},"Decompressing images to the bitmap cache"))),(0,n.kt)("h2",l({},{id:"conclusion"}),"Conclusion"),(0,n.kt)("p",null,"In this article we saw how to limit the flash usage of a TouchGFX application."),(0,n.kt)("p",null,"The 4 flash saving concepts can be used across all STM32 hardware platforms, but keep in mind that SVGs and vector fonts are expensive to render. As a result of this, performance can decrease if no hardware acceleration of vector rendering or extra computing power is available."),(0,n.kt)("p",null,"The concepts for flash-limited GUI development can result in a performance penalty, but it is possible to improve the performance by using dynamic bitmaps and cacheable containers."),(0,n.kt)("p",null,"By using the flash saving concepts there is a huge potential for saving flash. The exact amount of flash, the concepts can save, will depend on the specific application, but for the flash-limited E-bike demo, a flash saving of 92% is achieved."))}b.isMDXComponent=!0}}]);